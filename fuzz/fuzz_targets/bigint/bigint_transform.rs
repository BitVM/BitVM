#![no_main]

use std::iter::IntoIterator;
use std::sync::LazyLock;

use arbitrary::{Arbitrary, Result, Unstructured};
use bitcoin::ScriptBuf;
use bitcoin_script_stack::optimizer;
use bitvm::execute_script_buf;
use bitvm::hash::blake3::{
    blake3_compute_script, blake3_push_message_script_with_limb, blake3_verify_output_script,
};
use libfuzzer_sys::fuzz_target;


use bitvm::bigint::{BigIntImpl, U64, U254, U256};

pub type U384 = BigIntImpl<384, 29>; 

pub enum BigIntType {
    U64(U64),
    U254(U254),
    U256(U256),
    U384(U384), // We use 256bit (BN254), but test for others (e.g. BLS12-381)
}

impl BigIntType {
    pub fn from_index(idx: u32) -> Self {
        match idx {
            0 => Self::U64(U64{}),
            1 => Self::U254(U254{}),
            2 => Self::U256(U256{}),
            _ => panic!("Invalid BigIntType index")
        }
    }
}


// We are 99.999% confident with 500 limb transformations that all 32 values are covered (see inclusion-exclusion principle)
// This doesn't consider for every combination of limb transformations
pub struct BigIntConfig {
    pub bigint_type: BigIntType, 
    pub limb_size: u32,
    pub transform_list: [u32; 500], 
}

impl<'a> Arbitrary<'a> for BigIntConfig {
    fn arbitrary(u: &mut Unstructured<'a>) -> Result<Self> {
        let bigint_type = BigIntType::from_index(u.int_in_range(0..=2)?);
        let limb_size = u.int_in_range(1..=32)?;
        let transform_list  = std::array::from_fn(|| u.int_in_range(1..=32)?);

        Ok(BigIntConfig { bigint_type, limb_size, transform_list })
    }
}

// Todo: lazylock? and replace 500 with generic const?
// I want to maximize the generated bytes from this and keep track of it to push and compare on stack
fuzz_target!(|message: BigIntConfig| {
    
});